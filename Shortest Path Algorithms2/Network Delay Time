class Solution {
    class Pair {
        int node;
        int wt;

        Pair(int node, int wt) {
            this.node = node;
            this.wt = wt;
        }
    }

    public int networkDelayTime(int[][] times, int n, int k) {

        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            adj.add(new ArrayList<Pair>());
        }

        for (int i = 0; i < times.length; i++) {
            int u = times[i][0];
            int v = times[i][1];
            int wt = times[i][2];
            adj.get(u-1).add(new Pair(v-1, wt));  // for 1-based indexing 
        }

        int[] dist = new int[n];
        Arrays.fill(dist, Integer.MAX_VALUE);

        
            dist[k-1] = 0; // source node 

        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> a.wt - b.wt);

        pq.add(new Pair(k-1, 0)); 

        while (!pq.isEmpty()) {
            Pair current = pq.poll();

            int node = current.node;
            int wt = current.wt;
            if (wt > dist[node]) continue;  // ignore outdated entry
            for (Pair nei : adj.get(node)) {
                int edgeNode = nei.node;
                int edgeWt = nei.wt;
                if (edgeWt + wt < dist[edgeNode]) {
                    dist[edgeNode] = edgeWt + wt;
                    pq.add(new Pair(edgeNode, dist[edgeNode]));
                }
            }
        }

        int max = 0;
        for (int i = 0; i < dist.length; i++) {
            if (dist[i] == Integer.MAX_VALUE) // means we cannot reach all nodes so return -1 
                return -1;
            max = Math.max(max,dist[i]);
        }

    return max;
    }
}
